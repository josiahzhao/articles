# 关于ES数据读写那点事儿

## 1 对文档建索引
### 1.1 自定义文档ID
如果你的数据本身有自己的唯一标记，那么在建立索引时可以使用id来指定你的文档的id。
```
PUT /{index}/{type}/{id}
{
"field": "value", ...
}
```
如下，使用curl在your_index索引下写入一个id=1001的文档。
```
curl -H "Content-Type: application/json" -XPOST 'http://ip:port/your_index/_doc/1001' -d '
{
    "field": "内容"
}
'
```
返回如下
```
{
    "_index": "your_index",
    "_type": "_doc",
    "_id": "1001",
    "_version": 1,
    "result": "created"
}
```
可以看到除了index, type和id字段，还有一个version字段。

在ES中每个文档都有一个自己的version编号，每当文档发生变化时，version就会增长。

### 1.2 使用自增ID

如果你的文档没有唯一标识，你可以让ES帮你自动生成文档ID，对应请求的方式也要发生变化：不使用PUT方法(将这个文档存储在指定的ID上)，改使用POST方法(将这个文档存储在指定的索引下)，如下，只需要在URL中指定索引和类型。

```
curl -H "Content-Type: application/json" -XPOST 'http://ip:port/your_index/_doc' -d'
{
    "field": "内容"
}
'
```

可以看到自动生成一个22位字符的id，使用base64编码的UUID。
```
{
    "_index": "your_index",
    "_type": "_doc",
    "_id": "cZeQEYIBJnF0z3Du5UvX",
    "_version": 1,
    "result": "created"
}
```

## 2 获取文档

和之前的请求类似，使用GET请求获取id为1001的文档。

```
http://ip:port/your_index/_doc/1001?pretty
```

如下，返回的数据体在_source字段中，并且通过添加pretty可以让返回的内容具有更友好的格式。如果你查找的文档不存在，found字段会变为false（同时返回的HTTP状态码为404）。
```
{
  "_index" : "your_index",
  "_type" : "_doc",
  "_id" : "1001",
  "_version" : 1,
  "found" : true,
  "_source" : {
    "field" : "内容"
  }
}
```

## 3 只获取文档的部分字段

正常情况下GET请求会将文档的所有字段都进行返回。但如果你只需要部分字段的话，可以通过在URL中使用_source参数来控制需要返回的字段。

```
http://ip:port/your_index/_doc/1001?pretty&_source=field
```

如下，_source中只包含了需要的部分。
```
{
  "_index" : "your_index",
  "_type" : "_doc",
  "_id" : "1001",
  "_version" : 1,
  "found" : true,
  "_source" : {
    "field" : "内容"
  }
}
```

如果只是想要获取数据体而不需要数据体本身，那么只使用_source即可

```
http://ip:port/your_index/_doc/1001/_source
```
返回如下
```
{
    "field": "内容"
}
```

## 3 检查文档是否存在


index->type->id

version
Every document in Elasticsearch has a version number. Every time a change is made to a document (including deleting it), the _version number is incremented. In “Deal‐ ing with Conflicts” on page 45, we discuss how to use the _version number to ensure that one part of your application doesn’t overwrite changes made by another part.

自动生成id
Autogenerated IDs are 22 character long, URL-safe, Base64-encoded string univer‐ sally unique identifiers, or UUIDs.

## GET获取文档
pretty
获取文档的部分字段：GET /website/blog/123?_source=title,text
甚至只要source：GET /website/blog/123/_source
只检查文档是否存在：curl -i -XHEAD http://localhost:9200/website/blog/123

## UPDATE更新文档
首先，文档本质是只读的，不能修改的。
所以，如果要更新，就要完全替换掉原来的文档。

接口上：
返回的created告诉你是否已经存在
version会增加

更新流程：标记删除 => 添加新文档 => 随着新数据的录入再把标记删除的文档从后台逐步删除

后面有局部更新的接口，逻辑是类似的：获取旧的JSON文档 => 基于旧的和用户提交的进行合并修改 => 标记删除 => 添加新文档 => 随着新数据的录入再把标记删除的文档从后台逐步删除

所以，update就是将get再index整合成为了一个接口

## 创建文档

How can we be sure, when we index a document, that we are creating an entirely new document and not overwriting an existing one?

PUT /website/blog/123?op_type=create
PUT /website/blog/123/_create

If the request succeeds in creating a new document, Elasticsearch will return the usual metadata and an HTTP response code of 201 Created.
On the other hand, if a document with the same _index, _type, and _id already exists, Elasticsearch will respond with a 409 Conflict response code, and an error message like the following:


## 删除文档
As already mentioned in “Updating a Whole Document” on page 42, deleting a document doesn’t immediately remove the docu‐ ment from disk; it just marks it as deleted. Elasticsearch will clean up deleted documents in the background as you continue to index more data.

Even though the document doesn’t exist (found is false), the _version number has still been incremented. This is part of the internal bookkeeping, which ensures that changes are applied in the correct order across multiple nodes.

## 处理冲突

之前了解到，如果我们要更新一个文档，需要先读取到原始的文档，对其进行临时修改，然后重新新建这个文档。谁最后修改，谁的就生效，比如两个人同时读取，自行修改，谁最后重建这个文档，文档就是谁的样子。

大部分情况下都不影响：
1. 比如数据是从关系型数据库同步过来的，无所谓冲突
2. 比如虽然两个人都是修改，但就是按照先后顺序就好了，业务上可以承受另一个人的修改不生效

但是有时候就会影响，比如售卖一个东西，如图

补图补图补图补图补图补图补图补图

同时购买，都拿到100，都-1成为99，一起更新，结果还是99，实际上已经98了

当：
1. 更新变动的频率越快
2. 读取数据到更新数据的周期越长

越容易出现问题

在大数据的领域，通常有两种方式保障并发更新的正确性。

1. 悲观并发控制
   这个是关系型数据库广泛使用的，假设冲突修改会经常发生，所以会很严格的控制对数据资源的访问来防止冲突的发生。
比如：在读取数据时会将目标数据上锁，确保只有这个线程可以修改这条数据，期间其他线程无法对这条数据进行操作
1. 乐观并发控制
   也是ES使用的并发控制模式。这种模式假设冲突不经常发生，所以在尝试数据修改时不会加锁、不会阻碍其他线程对数据的访问。
   但是，如果在读取到更新期间发现数据有过更新记录，则阻止这次的更新操作并报错。
    剩下的交给调用方去判断，是继续使用新的数据再来一次更新





